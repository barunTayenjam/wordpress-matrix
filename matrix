#!/bin/bash
# Simplified WordPress Development Platform - All-in-One Management Script

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$SCRIPT_DIR"
DOMAIN_SUFFIX="127.0.0.1.nip.io"
COMPOSE_FILE="$PROJECT_ROOT/docker-compose.yml"
DOCKER_COMPOSE="docker-compose"  # Default fallback
DEFAULT_PHP_VERSION="8.3"  # Default PHP version for new sites

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Helper functions
log_info() { echo -e "${BLUE}â„¹ï¸  $1${NC}"; }
log_success() { echo -e "${GREEN}âœ… $1${NC}"; }
log_warning() { echo -e "${YELLOW}âš ï¸  $1${NC}"; }
log_error() { echo -e "${RED}âŒ $1${NC}"; }

# Load environment
if [[ -f "$PROJECT_ROOT/.env" ]]; then
    set -a
    source "$PROJECT_ROOT/.env"
    set +a
fi

# Use podman-compose instead of docker-compose
if command -v podman-compose >/dev/null 2>&1; then
    DOCKER_COMPOSE="podman-compose"
elif command -v docker-compose >/dev/null 2>&1; then
    DOCKER_COMPOSE="docker-compose"
else
    log_error "Neither docker-compose nor podman-compose found"
    exit 1
fi

# Main help
show_help() {
    cat << EOF
ðŸš€ Simplified WordPress Development Platform

Usage: ./matrix <command> [options]

 Site Management:
  create <name> [--php-version=X.X]  Create new WordPress site (default PHP: ${DEFAULT_PHP_VERSION})
  list              List all sites
  start <name>      Start specific site
  stop <name>       Stop specific site
  remove <name>     Remove site
  info <name>       Show site details

Environment Management:
  install [name]    One-command install (creates site and starts services)
  start             Start all sites, services, and frontend
  stop              Stop all services and frontend
  restart           Restart all services and frontend
  status            Show system status including frontend
  logs [site]       Show logs (all or specific site)
  clean             Clean up unused resources

 Code Quality:
   check [name] [path]   Run code quality checks (all sites or specific site/path)
   test                  Run tests
   fix                   Auto-fix code issues

 Site Maintenance:
   clone <src> <dst> Clone existing site
   reset <name>      Reset site to fresh install
   update <name>     Update WordPress core
   cache <name>      Clear site caches
   search-replace    Database search/replace
   backup <name>     Backup site database/files

 Development:
   shell <service>   Access container shell (wp, db, nginx)
   url <name>        Show site URLs
   import-db <n> <f> Import SQL dump (site name, file path)
   export-db <n> [f> Export database (site name, optional file)
   frontend <action> Manage frontend (start|stop|restart|status)

 System:
   health            Run system health check

  Examples:
    ./matrix create blog      # Create new site
    ./matrix create oldsite --php-version=7.4  # Create site with PHP 7.4
    ./matrix start            # Start everything including frontend
   ./matrix check            # Run quality checks on all sites
   ./matrix check blog       # Run quality checks on specific site
   ./matrix check blog wp-content/themes/custom-theme  # Check specific path
   ./matrix shell wp         # Access WordPress CLI
   ./matrix import-db blog dump.sql  # Import database
   ./matrix export-db blog backup.sql # Export database
   ./matrix clone blog blog-copy     # Clone site
   ./matrix reset blog --keep-plugins    # Reset site
   ./matrix update --all          # Update all sites
   ./matrix backup --all --compress  # Backup all sites
   ./matrix health                # Check system health

 Frontend:
  ./matrix start            # Starts frontend at http://localhost:8500
  ./matrix status            # Shows frontend status
  ./matrix stop            # Stops frontend with other services

EOF
}

# Site discovery
get_sites() {
    local sites=()
    # Get WordPress directories
    for dir in "$PROJECT_ROOT"/wp_*; do
        if [[ -d "$dir" ]]; then
            sites+=("$(basename "$dir" | sed 's/^wp_//')")
        fi
    done
    printf '%s\n' "${sites[@]}" | sort -u
}

# Check if site exists
site_exists() {
    local site_name="$1"
    [[ -d "$PROJECT_ROOT/wp_$site_name" ]]
}

# Get next available port
get_next_port() {
    local max_port=8100  # Start from 8100 to avoid conflicts with main services
    if [[ -f "$COMPOSE_FILE" ]]; then
        # Extract ports that are mapped to 80 (web services)
        # Look for lines with - "NNNN:80" under ports sections
        # Using sed to extract the port number from quoted port mappings
        local ports=$(grep -oE '^\s*-\s*"[0-9]+:80"' "$COMPOSE_FILE" 2>/dev/null | grep -oE '[0-9]+:80' | grep -oE '^[0-9]+' | sort -nr)
        if [[ -n "$ports" ]]; then
            max_port=$(echo "$ports" | head -n 1)
        fi
    fi
    # Find next available port that's not in use
    ((max_port++))
    while ss -tln 2>/dev/null | grep -q ":$max_port " 2>/dev/null; do
        ((max_port++))
    done
    echo $max_port
}

# Create new site
create_site() {
    local site_name=""
    local php_version="$DEFAULT_PHP_VERSION"
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --php-version=*)
                php_version="${1#*=}"
                shift
                ;;
            --php-version)
                php_version="$2"
                shift 2
                ;;
            -*)
                log_error "Unknown option: $1"
                return 1
                ;;
            *)
                if [[ -z "$site_name" ]]; then
                    site_name="$1"
                fi
                shift
                ;;
        esac
    done
    
    if [[ -z "$site_name" ]]; then
        read -p "Enter site name: " site_name
    fi
    
    if [[ -z "$site_name" ]]; then
        log_error "Site name required"
        return 1
    fi
    
    # Validate PHP version
    case "$php_version" in
        7.4|8.0|8.1|8.2|8.3)
            ;;
        *)
            log_error "Invalid PHP version: $php_version. Supported: 7.4, 8.0, 8.1, 8.2, 8.3"
            return 1
            ;;
    esac
    
    if site_exists "$site_name"; then
        log_error "Site '$site_name' already exists"
        return 1
    fi
    
    local port=$(get_next_port)
    local site_dir="$PROJECT_ROOT/wp_$site_name"
    
    log_info "Creating WordPress site: $site_name (PHP $php_version)"
    
    # Create directory
    mkdir -p "$site_dir"
    mkdir -p "$PROJECT_ROOT/logs/wp_$site_name"
    
    # Copy WordPress files using Docker/Podman
    log_info "Installing WordPress (PHP $php_version)..."
    if command -v docker >/dev/null 2>&1; then
        docker run --rm -v "$site_dir":/var/www/html wordpress:php${php_version}-fpm \
            bash -c "cp -a /usr/src/wordpress/. /var/www/html/ && chown -R www-data:www-data /var/www/html"
    elif command -v podman >/dev/null 2>&1; then
        podman run --rm -v "$site_dir":/var/www/html wordpress:php${php_version}-fpm \
            bash -c "cp -a /usr/src/wordpress/. /var/www/html/ && chown -R www-data:www-data /var/www/html"
    else
        log_error "Neither docker nor podman found"
        return 1
    fi
    
    # Create site-specific nginx configuration
    local nginx_conf_path="$PROJECT_ROOT/config/nginx/$site_name.conf"
    if [[ ! -d "$PROJECT_ROOT/config/nginx" ]]; then
        mkdir -p "$PROJECT_ROOT/config/nginx"
    fi

    cat > "$nginx_conf_path" << EOF
server {
    listen 80;
    server_name _;
    root /var/www/html;
    index index.php index.html;

    location / {
        try_files \$uri \$uri/ /index.php?\$query_string;
    }

    location ~ \.php\$ {
        fastcgi_pass wp_$site_name:9000;
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME \$document_root\$fastcgi_script_name;
        include fastcgi_params;
        
        # Increase buffer sizes to handle large headers
        fastcgi_buffer_size 32k;
        fastcgi_buffers 16 16k;
        fastcgi_busy_buffers_size 32k;
    }

    # Deny access to sensitive files
    location ~ /\. {
        deny all;
    }
}
EOF

    # Add to $DOCKER_COMPOSE.yml
    log_info "Adding services to $DOCKER_COMPOSE.yml..."

    # Create a temporary file and reconstruct the compose file properly
    local temp_file=$(mktemp)

    # Copy everything before volumes section (excluding the line with volumes:)
    awk '/^volumes:/ {exit} {if (!/^volumes:/) print}' "$COMPOSE_FILE" > "$temp_file"

    # Add the new services (with optional host port mapping as fallback)
    # Use semantic port assignment starting from 8100 for WordPress sites
    # Get next available port using our function
    local port=$(get_next_port)

    cat >> "$temp_file" << EOF

  # WordPress site: $site_name
  wp_$site_name:
    image: wordpress:php${php_version}-fpm
    container_name: wp_$site_name
    restart: unless-stopped
    environment:
      WORDPRESS_DB_HOST: db:3306
      WORDPRESS_DB_USER: \${MYSQL_USER:-wp_user}
      WORDPRESS_DB_PASSWORD: \${MYSQL_PASSWORD:-wp_password}
      WORDPRESS_DB_NAME: ${site_name}_db
      WORDPRESS_DEBUG: \${WP_DEBUG:-true}
    volumes:
      - ./wp_$site_name:/var/www/html
    networks:
      - wp-net
    depends_on:
      db:
        condition: service_healthy

  nginx_$site_name:
    image: nginx:alpine
    container_name: nginx_$site_name
    restart: unless-stopped
    ports:
      - "$port:80"  # Direct port mapping for reliable access
    depends_on:
      - wp_$site_name
    volumes:
      - ./wp_$site_name:/var/www/html:ro
      - $nginx_conf_path:/etc/nginx/conf.d/default.conf:ro
    networks:
      - wp-net

EOF

    # Copy the volumes section
    awk '/^volumes:/ {print; while(getline) print}' "$COMPOSE_FILE" >> "$temp_file"

    # Replace the original file
    mv "$temp_file" "$COMPOSE_FILE"

    # Create database and grant permissions
    if $DOCKER_COMPOSE ps db 2>/dev/null | grep -q "Up"; then
        $DOCKER_COMPOSE exec db mysql -u root -p"${MYSQL_ROOT_PASSWORD:-root}" \
            -e "CREATE DATABASE IF NOT EXISTS ${site_name}_db; GRANT ALL PRIVILEGES ON ${site_name}_db.* TO '${MYSQL_USER:-wp_user}'@'%'; FLUSH PRIVILEGES;" 2>/dev/null || true
    fi

    log_success "Site '$site_name' created successfully with PHP $php_version"
    echo "Direct: http://localhost:$port"  # Direct access via semantic port
    echo "Database: http://localhost:8200"  # phpMyAdmin access

    # Auto-start the site after creation
    log_info "Starting site '$site_name'..."
    $DOCKER_COMPOSE up -d wp_$site_name nginx_$site_name 2>/dev/null || true
    log_success "Site '$site_name' started and ready!"
}

# List all sites and services
list_sites() {
    log_info "WordPress Sites & Services:"
    echo ""
    
    # Get WordPress sites
    local sites=($(get_sites))
    
    # Show WordPress sites
    if [[ ${#sites[@]} -gt 0 ]]; then
        printf "%-15s %-10s %-30s %-30s\n" "WordPress Site" "Status" "Local URL" "Domain URL"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        
        for site in "${sites[@]}"; do
            local status="Stopped"

            # Get the port for the site by examining the compose file
            local port="Not configured"
            if [[ -f "$COMPOSE_FILE" ]]; then
                if grep -q "nginx_$site:" "$COMPOSE_FILE" 2>/dev/null; then
                    port=$(grep -A 15 "nginx_$site:" "$COMPOSE_FILE" 2>/dev/null | grep -E '^\s*-\s*"[0-9]+:80"' | grep -oE '[0-9]+' | head -1 || echo "")
                fi
                if [[ -z "$port" || "$port" == "" ]]; then
                    port="Not configured"
                fi
            fi

            if $DOCKER_COMPOSE ps --format "{{.Names}}" | grep -q "wp_$site"; then
                status="Running"
            fi

            local port_str="Not configured"
            if [[ "$port" != "Not configured" ]]; then
                port_str="http://localhost:$port"
            fi
            printf "%-15s %-10s %-30s %-30s\n" "$site" "$status" \
                "$port_str" \
                "Direct port access only"
        done
        echo ""
    fi
    
    # Show Management Services
    printf "%-15s %-10s %-30s %-30s\n" "Service" "Status" "Local URL" "Description"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    
    # Database
    local db_status="Stopped"
    if $DOCKER_COMPOSE ps --format "{{.Names}}" | grep -q "wp_db"; then
        db_status="Running"
    fi
    printf "%-15s %-10s %-30s %-30s\n" "Database" "$db_status" \
        "http://localhost:3306" \
        "MySQL Database Server"
    
    # Redis Cache
    local redis_status="Stopped"
    if $DOCKER_COMPOSE ps --format "{{.Names}}" | grep -q "wp_redis"; then
        redis_status="Running"
    fi
    printf "%-15s %-10s %-30s %-30s\n" "Redis Cache" "$redis_status" \
        "Internal" \
        "In-memory Cache"
    
    # phpMyAdmin
    local phpmyadmin_status="Stopped"
    if $DOCKER_COMPOSE ps --format "{{.Names}}" | grep -q "wp_phpmyadmin"; then
        phpmyadmin_status="Running"
    fi
    printf "%-15s %-10s %-30s %-30s\n" "phpMyAdmin" "$phpmyadmin_status" \
        "http://localhost:8200" \
        "Database Management"
    

    
    # Code Quality Tools
    local phpcs_status="Stopped"
    if $DOCKER_COMPOSE ps --format "{{.Names}}" | grep -q "wp_phpcs"; then
        phpcs_status="Running"
    fi
    printf "%-15s %-10s %-30s %-30s\n" "PHP CodeSniffer" "$phpcs_status" \
        "Tools Profile" \
        "Code Quality - WordPress Standards"
    
    local phpstan_status="Stopped"
    if $DOCKER_COMPOSE ps --format "{{.Names}}" | grep -q "wp_phpstan"; then
        phpstan_status="Running"
    fi
    printf "%-15s %-10s %-30s %-30s\n" "PHPStan" "$phpstan_status" \
        "Tools Profile" \
        "Code Quality - Static Analysis"
    
    local wpcli_status="Stopped"
    if $DOCKER_COMPOSE ps --format "{{.Names}}" | grep -q "wp_cli"; then
        wpcli_status="Running"
    fi
    printf "%-15s %-10s %-30s %-30s\n" "WP-CLI" "$wpcli_status" \
        "Tools Profile" \
        "WordPress Command Line"
    
    echo ""
}

# Start environment
start_env() {
    log_info "Starting WordPress environment..."
    $DOCKER_COMPOSE up -d db redis phpmyadmin 2>/dev/null || true
    sleep 3

    # Start frontend if available
    if [[ -d "$PROJECT_ROOT/frontend" ]]; then
        manage_frontend start
    fi

    log_success "Environment started"
    echo ""
    echo "Core services running: database, redis, phpMyAdmin"
    echo ""
    echo "Start sites individually: ./matrix start <site>"
    
    # Show frontend URL
    if [[ -f "$PROJECT_ROOT/.frontend.pid" ]]; then
        local pid=$(cat "$PROJECT_ROOT/.frontend.pid")
        if ps -p "$pid" > /dev/null 2>&1; then
            echo "Frontend: http://localhost:8500"
        fi
    fi
}

# Stop environment
stop_env() {
    log_info "Stopping WordPress environment..."
    
    # Stop frontend first if running
    if [[ -d "$PROJECT_ROOT/frontend" ]]; then
        manage_frontend stop
    fi
    
    $DOCKER_COMPOSE down
    log_success "Environment stopped"
}

# Show status
show_status() {
    log_info "System Status:"
    echo ""
    $DOCKER_COMPOSE ps
    echo ""
    
    # Show frontend status if available
    if [[ -d "$PROJECT_ROOT/frontend" ]]; then
        manage_frontend status 2>/dev/null || echo "Frontend: Unknown"
    fi
    
    list_sites
}

# Show logs
show_logs() {
    local service="$1"
    
    if [[ -n "$service" ]]; then
        if [[ "$service" == "db" ]]; then
            $DOCKER_COMPOSE logs -f db
        elif [[ "$service" == "nginx" ]]; then
            local nginx_containers=($($DOCKER_COMPOSE ps --format "{{.Names}}" 2>/dev/null | grep "^nginx_" || true))
            if [[ ${#nginx_containers[@]} -gt 0 ]]; then
                $DOCKER_COMPOSE logs -f "${nginx_containers[0]}"
            else
                log_error "No nginx containers running"
            fi
        else
            $DOCKER_COMPOSE logs -f "wp_$service" "nginx_$service" 2>/dev/null || \
            $DOCKER_COMPOSE logs -f "$service"
        fi
    else
        $DOCKER_COMPOSE logs -f
    fi
}

# Remove site
remove_site() {
    local site_name="$1"

    if ! site_exists "$site_name"; then
        log_error "Site '$site_name' not found"
        return 1
    fi

    echo -e "${RED}WARNING: This will permanently delete '$site_name'${NC}"
    read -p "Continue? [y/N]: " confirm

    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        log_info "Cancelled"
        return
    fi

    log_info "Removing site '$site_name'..."

    # Stop services
    $DOCKER_COMPOSE stop "wp_$site_name" "nginx_$site_name" 2>/dev/null || true
    $DOCKER_COMPOSE rm -f "wp_$site_name" "nginx_$site_name" 2>/dev/null || true

    # Remove files
    rm -rf "$PROJECT_ROOT/wp_$site_name"
    rm -rf "$PROJECT_ROOT/logs/wp_$site_name"

    # Remove database
    if $DOCKER_COMPOSE ps db 2>/dev/null | grep -q "Up"; then
        $DOCKER_COMPOSE exec db mysql -u root -p"${MYSQL_ROOT_PASSWORD:-root}" \
            -e "DROP DATABASE IF EXISTS ${site_name}_db; REVOKE ALL PRIVILEGES ON ${site_name}_db.* FROM '${MYSQL_USER:-wp_user}'@'%'; FLUSH PRIVILEGES;" 2>/dev/null || true
    fi

    # Remove service definitions from docker-compose.yml
    if [[ -f "$COMPOSE_FILE" ]]; then
        # Use a more reliable approach to remove service blocks
        # Remove the comment line and associated services using sed with address ranges
        sed -i.bak "/# WordPress site: $site_name/,/^[^[:space:]]/{
            /# WordPress site: $site_name/!{
                /^[^[:space:]]/!d;
            };
            /# WordPress site: $site_name/d;
        }" "$COMPOSE_FILE" 2>/dev/null || true

        # Clean up backup file created by sed -i
        [[ -f "$COMPOSE_FILE.bak" ]] && rm "$COMPOSE_FILE.bak"
    fi

    # Remove from .env file
    if [[ -f "$PROJECT_ROOT/.env" ]]; then
        local env_var_name=$(echo "$site_name" | tr '[:lower:]' '[:upper:]' | tr '-' '_')
        local temp_env=$(mktemp)
        grep -v "^${env_var_name}_PORT=" "$PROJECT_ROOT/.env" > "$temp_env"
        # Also remove the comment line that identifies the site
        grep -v "^# Site: $site_name" "$temp_env" > "$PROJECT_ROOT/.env"
        rm -f "$temp_env"
    fi

    log_success "Site '$site_name' removed"
}

# Code quality checks
run_checks() {
    local site_name="${1:-}"
    local specific_path="${2:-}"
    local target_paths=""
    
    if [[ -n "$site_name" ]]; then
        local site_dir="wp_${site_name}"
        if [[ ! -d "$site_dir" ]]; then
            log_error "Site '$site_name' not found (directory: $site_dir)"
            return 1
        fi
        
        if [[ -n "$specific_path" ]]; then
            target_paths="./${site_dir}/${specific_path}"
            log_info "Running code quality checks on: $site_name/$specific_path"
        else
            target_paths="./${site_dir}/wp-content/themes/ ./${site_dir}/wp-content/plugins/"
            log_info "Running code quality checks on site: $site_name"
            log_info "Excluding default WordPress themes, vendor, and common plugins"
        fi
    else
        target_paths="./wp_*/wp-content/themes/ ./wp_*/wp-content/plugins/"
        log_info "Running code quality checks on all sites..."
        log_info "Excluding default WordPress themes, vendor, and common plugins"
    fi
    
    # Check if code quality containers exist in $DOCKER_COMPOSE
    if ! grep -q "phpcs" "$COMPOSE_FILE" 2>/dev/null; then
        log_warning "Code quality tools not configured"
        return
    fi
    
    # Build exclude patterns for default/third-party themes and plugins
    local exclude_patterns=""
    exclude_patterns="$exclude_patterns --ignore=*/vendor/*"
    exclude_patterns="$exclude_patterns --ignore=*/node_modules/*"
    exclude_patterns="$exclude_patterns --ignore=*/.git/*"
    exclude_patterns="$exclude_patterns --ignore=*/tests/*"
    exclude_patterns="$exclude_patterns --ignore=*/twentytwenty*/*"
    exclude_patterns="$exclude_patterns --ignore=*/twenty*/*"
    exclude_patterns="$exclude_patterns --ignore=*/index.php"
    exclude_patterns="$exclude_patterns --ignore=*/akismet/*"
    exclude_patterns="$exclude_patterns --ignore=*/hello.php"
    exclude_patterns="$exclude_patterns --ignore=*/advanced-custom-fields*/*"
    exclude_patterns="$exclude_patterns --ignore=*/elementor/*"
    exclude_patterns="$exclude_patterns --ignore=*/wordpress-seo/*"
    exclude_patterns="$exclude_patterns --ignore=*/redirection/*"
    exclude_patterns="$exclude_patterns --ignore=*/litespeed-cache/*"
    exclude_patterns="$exclude_patterns --ignore=*/better-search-replace/*"
    exclude_patterns="$exclude_patterns --ignore=*/defender*/*"
    exclude_patterns="$exclude_patterns --ignore=*/sg-security/*"
    exclude_patterns="$exclude_patterns --ignore=*/duplicate-page/*"
    exclude_patterns="$exclude_patterns --ignore=*/really-simple-ssl/*"
    exclude_patterns="$exclude_patterns --ignore=*/classic-elementor*/*"
    exclude_patterns="$exclude_patterns --ignore=*/revslider/*"
    exclude_patterns="$exclude_patterns --ignore=*/export-posts*/*"
    exclude_patterns="$exclude_patterns --ignore=*/csv-taxonomy*/*"
    exclude_patterns="$exclude_patterns --ignore=*/wp-file-manager/*"
    
    # Run PHP CodeSniffer
    log_info "Running PHP CodeSniffer..."
    $DOCKER_COMPOSE --profile tools run --rm phpcs \
        -d memory_limit=512M \
        --standard=WordPress \
        --extensions=php \
        $exclude_patterns \
        $target_paths 2>/dev/null || \
    log_warning "PHP CodeSniffer check completed with issues"
    
    # Run PHPStan (only on custom code to avoid timeout)
    if [[ -n "$specific_path" ]]; then
        log_info "Running PHPStan..."
        $DOCKER_COMPOSE --profile tools run --rm phpstan analyse \
            --memory-limit=512M \
            $target_paths --level=5 2>/dev/null || \
        log_warning "PHPStan check completed with issues"
    else
        log_info "Skipping PHPStan (use specific path to run PHPStan: ./matrix check <site> <path>)"
    fi
    
    log_info "Code quality checks completed"
}

# Access shell
access_shell() {
    local service="$1"
    
    case "$service" in
        "wp"|"wordpress")
            # Get running WordPress containers (exclude db, redis, and other services)
            local running_containers=($($DOCKER_COMPOSE ps --format "{{.Names}}" 2>/dev/null | grep "^wp_" | grep -vE "wp_db|wp_redis|wp_phpmyadmin|wp_phpcs|wp_phpstan|wp_cli" || true))
            if [[ ${#running_containers[@]} -eq 0 ]]; then
                log_error "No WordPress containers running"
                return 1
            fi
            
            # Use first running WordPress container
            local container_name="${running_containers[0]}"
            echo "Accessing container: $container_name"
            $DOCKER_COMPOSE exec "$container_name" bash || \
            log_error "Failed to access WordPress container"
            ;;
        "db"|"database")
            $DOCKER_COMPOSE exec db mysql -u root -p"${MYSQL_ROOT_PASSWORD:-root}"
            ;;
        "nginx"|"proxy")
            local nginx_containers=($($DOCKER_COMPOSE ps --format "{{.Names}}" 2>/dev/null | grep "^nginx_" || true))
            if [[ ${#nginx_containers[@]} -eq 0 ]]; then
                log_error "No nginx containers running"
                return 1
            fi
            
            # Use first running nginx container
            local container_name="${nginx_containers[0]}"
            echo "Accessing container: $container_name"
            $DOCKER_COMPOSE exec "$container_name" sh || \
            log_error "Failed to access nginx container"
            ;;
        *)
            log_error "Unknown service: $service"
            echo "Available: wp, db, nginx"
            return 1
            ;;
    esac
}

# Show URLs
show_urls() {
    local site_name="${1:-}"

    if [[ -n "$site_name" ]]; then
        if site_exists "$site_name"; then
            # Get the port for the site by examining the compose file
            local port=""
            if [[ -f "$COMPOSE_FILE" ]]; then
                if grep -q "nginx_$site_name:" "$COMPOSE_FILE" 2>/dev/null; then
                    port=$(grep -A 15 "nginx_$site_name:" "$COMPOSE_FILE" | grep -E '^\s*-\s*"[0-9]+:80"' | grep -oE '[0-9]+' | head -1)
                fi
            fi
            if [[ -z "$port" || "$port" == "" ]]; then
                echo "Site '$site_name' exists but is not configured in docker-compose.yml"
                echo "Use './matrix create $site_name' to configure it properly"
                return 0
            else
                echo "Access: http://localhost:$port"
                echo "Database: http://localhost:8200"
            fi
        else
            log_error "Site '$site_name' not found"
            return 1
        fi
    else
        echo "Services:"
        echo "WordPress sites: http://localhost:[assigned_port]"
        echo "Database admin: http://localhost:8200"
        echo "Email viewer: https://mailhog.$DOMAIN_SUFFIX"
    fi
}

# Setup environment
setup_env() {
    log_info "Setting up simplified WordPress environment..."
    
    # Create .env if not exists
    if [[ ! -f "$PROJECT_ROOT/.env" ]]; then
        cat > "$PROJECT_ROOT/.env" << EOF
# Simplified WordPress Environment
DOMAIN_SUFFIX=127.0.0.1.nip.io
MYSQL_USER=wp_user
MYSQL_PASSWORD=wp_password
MYSQL_ROOT_PASSWORD=root_password
WP_DEBUG=true
EOF
        log_success "Created .env file"
    fi
    
    # Create simplified $DOCKER_COMPOSE.yml if not exists
    if [[ ! -f "$PROJECT_ROOT/$DOCKER_COMPOSE.yml" ]]; then
        cat > "$PROJECT_ROOT/$DOCKER_COMPOSE.yml" << EOF
version: '3.8'

networks:
  wp-net:
    driver: bridge

services:
  # Database
  db:
    image: mysql:8.0
    container_name: wp_db
    restart: unless-stopped
    ports:
      - "3306:3306"
    environment:
      MYSQL_ROOT_PASSWORD: \${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: wp_main
      MYSQL_USER: \${MYSQL_USER}
      MYSQL_PASSWORD: \${MYSQL_PASSWORD}
    volumes:
      - wp_db_data:/var/lib/mysql
    networks:
      - wp-net

  # Cache
  redis:
    image: redis:alpine
    container_name: wp_redis
    restart: unless-stopped
    networks:
      - wp-net

volumes:
  wp_db_data:
EOF
        log_success "Created $DOCKER_COMPOSE.yml"
    fi
    
    # Create config directories
    mkdir -p "$PROJECT_ROOT/config/nginx"
    
    # Create default nginx config
    if [[ ! -f "$PROJECT_ROOT/config/nginx/default.conf" ]]; then
        cat > "$PROJECT_ROOT/config/nginx/default.conf" << 'EOF'
server {
    listen 80 default_server;
    server_name _;
    root /var/www/html;
    index index.php index.html;

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location ~ \.php$ {
        fastcgi_pass localhost:9000;  # Default to localhost for single container use
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    }
}
EOF
        log_success "Created default nginx configuration"
    fi
    
    # Ensure the wp_ directory exists for the main project (if this is the root)
    if [[ ! -d "$PROJECT_ROOT/wp_" ]]; then
        mkdir -p "$PROJECT_ROOT/wp_"
        # This is for the main project directory if needed
    fi

    log_success "Setup complete! Run './matrix start' to begin"
}

# Install complete WordPress environment with one command
install_env() {
    local site_name="${1:-wordpress}"

    log_info "Installing complete WordPress environment..."

    # Make sure we have the simple compose file
    if [[ ! -f "$PROJECT_ROOT/docker-compose.simple.yml" ]]; then
        log_error "docker-compose.simple.yml not found"
        return 1
    fi

    # Always create or overwrite the compose file with Traefik-free version
    cat > "$PROJECT_ROOT/docker-compose.yml" << 'EOF'
version: '3.8'

networks:
  wp-net:
    driver: bridge

services:
  # Database
  db:
    image: mysql:8.0
    container_name: wp_db
    restart: unless-stopped
    ports:
      - "3306:3306"
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: wp_main
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
    volumes:
      - wp_db_data:/var/lib/mysql
    networks:
      - wp-net
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      timeout: 20s
      retries: 10

  # Cache
  redis:
    image: redis:alpine
    container_name: wp_redis
    restart: unless-stopped
    networks:
      - wp-net
    command: redis-server --maxmemory 256mb --maxmemory-policy allkeys-lru

  # Database admin panel
  phpmyadmin:
    image: phpmyadmin:latest
    container_name: wp_phpmyadmin
    restart: unless-stopped
    ports:
      - "8200:80"  # Direct access to phpMyAdmin
    environment:
      PMA_HOST: db
      PMA_USER: ${MYSQL_USER:-wp_user}
      PMA_PASSWORD: ${MYSQL_PASSWORD:-wp_password}
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD:-root}
    networks:
      - wp-net
    depends_on:
      - db

volumes:
  wp_db_data:
EOF
    log_success "Created Traefik-free docker-compose.yml"

    # Run setup if .env doesn't exist
    if [[ ! -f "$PROJECT_ROOT/.env" ]]; then
        setup_env
    fi

    # Start the base services (db, redis)
    log_info "Starting base services..."
    $DOCKER_COMPOSE up -d db redis

    # Wait for database to be ready
    log_info "Waiting for database to be ready..."
    local max_attempts=30
    local attempt=1
    while [[ $attempt -le $max_attempts ]]; do
        if $DOCKER_COMPOSE exec db mysqladmin ping -h localhost -u "${MYSQL_USER:-wp_user}" -p"${MYSQL_PASSWORD:-wp_password}" --silent; then
            log_success "Database is ready!"
            break
        else
            log_info "Waiting for database... ($attempt/$max_attempts)"
            sleep 5
            ((attempt++))
        fi
    done

    if [[ $attempt -gt $max_attempts ]]; then
        log_error "Database failed to start after $max_attempts attempts"
        return 1
    fi

    # Check if site already exists
    if ! site_exists "$site_name"; then
        log_info "Creating WordPress site: $site_name"
        create_site "$site_name"
    else
        log_info "Site '$site_name' already exists"
    fi

    # Start all services
    log_info "Starting all services..."
    start_env

    log_success "WordPress environment installed successfully!"
    echo ""
    echo "Your site is available at:"
    echo "  http://localhost:[port]"
    echo ""
    log_success "Installation complete! ðŸš€"
}

# Database import function
import_db() {
    local site_name="$1"
    local dump_file="$2"

    if [[ -z "$site_name" || -z "$dump_file" ]]; then
        log_error "Usage: ./matrix import-db <site-name> </path/to/dump.sql>"
        return 1
    fi

    if [[ ! -f "$dump_file" ]]; then
        log_error "Dump file not found: $dump_file"
        return 1
    fi

    if ! site_exists "$site_name"; then
        log_error "Site '$site_name' not found"
        return 1
    fi

    local db_name="${site_name}_db"
    log_info "Importing database for '$site_name' ($db_name)..."

    # Set log_bin_trust_function_creators to allow triggers/procedures without SUPER privilege
    $DOCKER_COMPOSE exec -T db mysql -u root -p"${MYSQL_ROOT_PASSWORD:-root}" -e "SET GLOBAL log_bin_trust_function_creators = 1;" 2>/dev/null || true

    # Import the SQL dump
    cat "$dump_file" | $DOCKER_COMPOSE exec -T db mysql -u "${MYSQL_USER:-wp_user}" -p"${MYSQL_PASSWORD:-wp_password}" "$db_name"

    if [[ $? -eq 0 ]]; then
        log_success "Database imported successfully for '$site_name'"
    else
        log_error "Failed to import database for '$site_name'"
        return 1
    fi
}

# Database export function
export_db() {
    local site_name="$1"
    local output_file="$2"

    if [[ -z "$site_name" ]]; then
        log_error "Usage: ./matrix export-db <site-name> [/path/to/output.sql]"
        return 1
    fi

    if ! site_exists "$site_name"; then
        log_error "Site '$site_name' not found"
        return 1
    fi

    local db_name="${site_name}_db"

    if [[ -z "$output_file" ]]; then
        output_file="${site_name}_$(date +%Y%m%d_%H%M%S).sql"
        log_info "Exporting database for '$site_name' to $output_file..."
    else
        log_info "Exporting database for '$site_name' to $output_file..."
    fi

    # Export the database
    $DOCKER_COMPOSE exec db mysqldump -u "${MYSQL_USER:-wp_user}" -p"${MYSQL_PASSWORD:-wp_password}" "$db_name" > "$output_file"

    if [[ $? -eq 0 ]]; then
        log_success "Database exported successfully to '$output_file'"
        echo "File size: $(du -h "$output_file" | cut -f1)"
    else
        log_error "Failed to export database for '$site_name'"
        return 1
    fi
}

# Clean up
clean_env() {
    log_warning "This will remove unused Docker resources"
    read -p "Continue? [y/N]: " confirm

    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        $DOCKER_COMPOSE system prune -f 2>/dev/null || docker system prune -f
        $DOCKER_COMPOSE volume prune -f 2>/dev/null || docker volume prune -f
        log_success "Cleanup complete"
    fi
}

# Frontend management
manage_frontend() {
    local action="$1"

    if [[ -z "$action" ]]; then
        log_error "Usage: ./matrix frontend <start|stop|restart|status>"
        return 1
    fi

    local frontend_dir="$PROJECT_ROOT/frontend"
    local pid_file="$PROJECT_ROOT/.frontend.pid"
    local log_file="$PROJECT_ROOT/logs/frontend.log"

    # Create logs directory if it doesn't exist
    mkdir -p "$(dirname "$log_file")"

    case "$action" in
        "start")
            if [[ -f "$pid_file" ]]; then
                local pid=$(cat "$pid_file")
                if ps -p "$pid" > /dev/null 2>&1; then
                    log_warning "Frontend is already running (PID: $pid)"
                    return 0
                else
                    rm -f "$pid_file"
                fi
            fi

            if [[ ! -d "$frontend_dir" ]]; then
                log_error "Frontend directory not found: $frontend_dir"
                return 1
            fi

            log_info "Starting frontend..."
            cd "$frontend_dir" || return 1

            # Start frontend in background with logging
            PORT=8500 npm start > "$log_file" 2>&1 &
            local pid=$!
            echo $pid > "$pid_file"

            # Wait a moment and check if it started successfully
            sleep 2
            if ps -p "$pid" > /dev/null 2>&1; then
                log_success "Frontend started: http://localhost:8500 (PID: $pid)"
            else
                log_error "Failed to start frontend. Check logs: $log_file"
                rm -f "$pid_file"
                return 1
            fi
            ;;
        "stop")
            if [[ ! -f "$pid_file" ]]; then
                log_warning "Frontend is not running (no PID file found)"
                # Try to find and kill any process on port 8500
                local port_pid=$(lsof -ti:8500 2>/dev/null)
                if [[ -n "$port_pid" ]]; then
                    kill "$port_pid" 2>/dev/null
                    log_success "Frontend stopped (killed process on port 8500)"
                fi
                return 0
            fi

            local pid=$(cat "$pid_file")
            if ps -p "$pid" > /dev/null 2>&1; then
                log_info "Stopping frontend..."
                kill "$pid" 2>/dev/null
                sleep 1

                # Force kill if still running
                if ps -p "$pid" > /dev/null 2>&1; then
                    kill -9 "$pid" 2>/dev/null
                fi

                rm -f "$pid_file"
                log_success "Frontend stopped"
            else
                log_warning "Frontend process not found (PID: $pid)"
                rm -f "$pid_file"
            fi
            ;;
        "restart")
            log_info "Restarting frontend..."
            manage_frontend stop
            sleep 1
            manage_frontend start
            ;;
        "status")
            local is_running=false
            local pid=""

            if [[ -f "$pid_file" ]]; then
                pid=$(cat "$pid_file")
                if ps -p "$pid" > /dev/null 2>&1; then
                    is_running=true
                fi
            fi

            # Also check by port
            if ! $is_running; then
                local port_pid=$(lsof -ti:8500 2>/dev/null)
                if [[ -n "$port_pid" ]]; then
                    is_running=true
                    pid=$port_pid
                fi
            fi

            if $is_running; then
                echo "Frontend: Running (http://localhost:8500) - PID: $pid"
            else
                echo "Frontend: Stopped"
            fi
            ;;
        *)
            log_error "Unknown action: $action"
            log_info "Available: start, stop, restart, status"
            return 1
            ;;
    esac
}

# Main command dispatcher
main() {
    if [[ $# -eq 0 ]]; then
        show_help
        return
    fi
    
    local command="$1"
    shift
    
    case "$command" in
        "setup")
            setup_env "$@"
            ;;
        "start")
            # Check if a site name was provided
            if [[ -n "${1:-}" ]]; then
                # Start a specific site
                local site_name="$1"
                if [[ ! -d "$PROJECT_ROOT/wp_${site_name}" ]]; then
                    log_error "Site '$site_name' not found"
                    exit 1
                fi

                log_info "Starting site '$site_name'..."
                $DOCKER_COMPOSE up -d "wp_${site_name}" "nginx_${site_name}" 2>/dev/null || true
                log_success "Site '$site_name' started"

                # Show site URL
                show_urls "$site_name"
            else
                # Start entire environment
                start_env
            fi
            ;;
        "stop")
            # Check if a site name was provided
            if [[ -n "${1:-}" ]]; then
                # Stop a specific site
                local site_name="$1"
                if [[ ! -d "$PROJECT_ROOT/wp_${site_name}" ]]; then
                    log_error "Site '$site_name' not found"
                    exit 1
                fi

                log_info "Stopping site '$site_name'..."
                $DOCKER_COMPOSE stop "wp_${site_name}" "nginx_${site_name}" 2>/dev/null || true
                log_success "Site '$site_name' stopped"
            else
                # Stop entire environment
                stop_env
            fi
            ;;
        "restart")
            stop_env
            start_env
            ;;
        "status")
            show_status "$@"
            ;;
        "logs")
            show_logs "$@"
            ;;
        "create")
            create_site "$@"
            ;;
        "list"|"ls")
            list_sites "$@"
            ;;
        "remove"|"rm")
            remove_site "$@"
            ;;
        "info")
            show_urls "$@"
            ;;
        "check"|"quality")
            run_checks "$@"
            ;;
        "test")
            run_checks "$@"  # Same as check for now
            ;;
        "fix")
            log_info "Auto-fix not implemented yet"
            ;;
        "shell")
            access_shell "$@"
            ;;
        "url"|"urls")
            show_urls "$@"
            ;;
        "clean")
            clean_env "$@"
            ;;
        "install")
            install_env "$@"
            ;;
        "import-db")
            import_db "$@"
            ;;
        "export-db")
            export_db "$@"
            ;;
        "frontend")
            manage_frontend "$@"
            ;;
        "clone")
            "$PROJECT_ROOT/scripts/clone.sh" "$@"
            ;;
        "reset")
            "$PROJECT_ROOT/scripts/reset.sh" "$@"
            ;;
        "update"|"update-core")
            "$PROJECT_ROOT/scripts/update-core.sh" "$@"
            ;;
        "cache"|"cache-clear")
            "$PROJECT_ROOT/scripts/cache-clear.sh" "$@"
            ;;
        "search-replace")
            "$PROJECT_ROOT/scripts/search-replace.sh" "$@"
            ;;
        "backup")
            "$PROJECT_ROOT/scripts/backup.sh" "$@"
            ;;
        "health")
            "$PROJECT_ROOT/scripts/health-check.sh"
            ;;
        "help"|"-h"|"--help")
            show_help
            ;;
        *)
            log_error "Unknown command: $command"
            show_help
            return 1
            ;;
    esac
}

main "$@"