#!/bin/bash
# Simplified WordPress Development Platform - All-in-One Management Script

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$SCRIPT_DIR"
DOMAIN_SUFFIX="127.0.0.1.nip.io"
COMPOSE_FILE="$PROJECT_ROOT/docker-compose.yml"
DOCKER_COMPOSE="docker-compose"  # Default fallback

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Helper functions
log_info() { echo -e "${BLUE}â„¹ï¸  $1${NC}"; }
log_success() { echo -e "${GREEN}âœ… $1${NC}"; }
log_warning() { echo -e "${YELLOW}âš ï¸  $1${NC}"; }
log_error() { echo -e "${RED}âŒ $1${NC}"; }

# Load environment
if [[ -f "$PROJECT_ROOT/.env" ]]; then
    set -a
    source "$PROJECT_ROOT/.env"
    set +a
fi

# Use podman-compose instead of docker-compose
if command -v podman-compose >/dev/null 2>&1; then
    DOCKER_COMPOSE="podman-compose"
elif command -v docker-compose >/dev/null 2>&1; then
    DOCKER_COMPOSE="docker-compose"
else
    log_error "Neither docker-compose nor podman-compose found"
    exit 1
fi

# Main help
show_help() {
    cat << EOF
ðŸš€ Simplified WordPress Development Platform

Usage: ./wp-simple <command> [options]

Site Management:
  create <name>     Create new WordPress site
  list              List all sites
  start <name>      Start specific site
  stop <name>       Stop specific site
  remove <name>     Remove site
  info <name>       Show site details

Environment Management:
  install [name]    One-command install (creates site and starts services)
  start             Start all sites and services
  stop              Stop all services
  restart           Restart all services
  status            Show system status
  logs [site]       Show logs (all or specific site)
  clean             Clean up unused resources

Code Quality:
  check             Run code quality checks
  test              Run tests
  fix               Auto-fix code issues

Development:
  shell <service>   Access container shell (wp, db, nginx)
  url <name>        Show site URLs
  import-db <n> <f> Import SQL dump (site name, file path)
  export-db <n> [f] Export database (site name, optional file)

Examples:
  ./wp-simple create blog      # Create new site
  ./wp-simple start            # Start everything
  ./wp-simple check            # Run quality checks
  ./wp-simple shell wp         # Access WordPress CLI
  ./wp-simple import-db blog dump.sql  # Import database
  ./wp-simple export-db blog backup.sql # Export database

EOF
}

# Site discovery
get_sites() {
    local sites=()
    # Get WordPress directories
    for dir in "$PROJECT_ROOT"/wp_*; do
        if [[ -d "$dir" ]]; then
            sites+=("$(basename "$dir" | sed 's/^wp_//')")
        fi
    done
    printf '%s\n' "${sites[@]}" | sort -u
}

# Check if site exists
site_exists() {
    local site_name="$1"
    [[ -d "$PROJECT_ROOT/wp_$site_name" ]]
}

# Get next available port
get_next_port() {
    local max_port=8000
    if [[ -f "$COMPOSE_FILE" ]]; then
        # Extract ports that are mapped to 80 (web services)
        # Look for lines with - "NNNN:80" under ports sections
        # Using sed to extract the port number from quoted port mappings
        local ports=$(grep -oE '^\s*-\s*"[0-9]+:80"' "$COMPOSE_FILE" 2>/dev/null | grep -oE '[0-9]+:80' | grep -oE '^[0-9]+' | sort -nr)
        if [[ -n "$ports" ]]; then
            max_port=$(echo "$ports" | head -n 1)
        fi
    fi
    echo $((max_port + 1))
}

# Create new site
create_site() {
    local site_name="$1"
    
    if [[ -z "$site_name" ]]; then
        read -p "Enter site name: " site_name
    fi
    
    if [[ -z "$site_name" ]]; then
        log_error "Site name required"
        return 1
    fi
    
    if site_exists "$site_name"; then
        log_error "Site '$site_name' already exists"
        return 1
    fi
    
    local port=$(get_next_port)
    local site_dir="$PROJECT_ROOT/wp_$site_name"
    
    log_info "Creating WordPress site: $site_name"
    
    # Create directory
    mkdir -p "$site_dir"
    mkdir -p "$PROJECT_ROOT/logs/wp_$site_name"
    
    # Copy WordPress files using Docker/Podman
    log_info "Installing WordPress..."
    if command -v docker >/dev/null 2>&1; then
        docker run --rm -v "$site_dir":/var/www/html wordpress:latest \
            bash -c "cp -a /usr/src/wordpress/. /var/www/html/ && chown -R www-data:www-data /var/www/html"
    elif command -v podman >/dev/null 2>&1; then
        podman run --rm -v "$site_dir":/var/www/html wordpress:latest \
            bash -c "cp -a /usr/src/wordpress/. /var/www/html/ && chown -R www-data:www-data /var/www/html"
    else
        log_error "Neither docker nor podman found"
        return 1
    fi
    
    # Create site-specific nginx configuration
    local nginx_conf_path="$PROJECT_ROOT/config/nginx/$site_name.conf"
    cat > "$nginx_conf_path" << 'EOF_NGINX'
server {
    listen 80;
    server_name _;
    root /var/www/html;
    index index.php index.html;

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location ~ \.php$ {
        fastcgi_pass wp_container_name:9000;  # To be replaced with actual wp service name
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    }
}
EOF_NGINX

    # Replace wp_container_name with the actual wp service name for this site
    sed -i.bak "s/wp_container_name/wp_$site_name/g" "$nginx_conf_path" && rm "$nginx_conf_path.bak"

    # Add to $DOCKER_COMPOSE.yml
    log_info "Adding services to $DOCKER_COMPOSE.yml..."

    # Create a temporary file and reconstruct the compose file properly
    local temp_file=$(mktemp)

    # Copy everything before volumes section (excluding the line with volumes:)
    awk '/^volumes:/ {exit} {if (!/^volumes:/) print}' "$COMPOSE_FILE" > "$temp_file"

    # Add the new services (with optional host port mapping as fallback)
    # Use semantic port assignment starting from 8100 for WordPress sites
    # Find available port starting from 8100
    local port=8100
    while $DOCKER_COMPOSE port nginx_${site_name} 80 &>/dev/null || \
          docker port nginx_${site_name} 80 &>/dev/null || \
          (netstat -an | grep -q ":$port "); do
        port=$((port + 1))
        # Safety check to avoid infinite loop
        if [[ $port -gt 8200 ]]; then
            log_warning "High port assignment detected, using: $port"
            break
        fi
    done

    cat >> "$temp_file" << EOF

  # WordPress site: $site_name
  wp_$site_name:
    image: wordpress:php8.3-fpm
    container_name: wp_$site_name
    restart: unless-stopped
    environment:
      WORDPRESS_DB_HOST: db:3306
      WORDPRESS_DB_USER: \${MYSQL_USER:-wp_user}
      WORDPRESS_DB_PASSWORD: \${MYSQL_PASSWORD:-wp_password}
      WORDPRESS_DB_NAME: ${site_name}_db
      WORDPRESS_DEBUG: \${WP_DEBUG:-true}
    volumes:
      - ./wp_$site_name:/var/www/html
    networks:
      - wp-net
    depends_on:
      db:
        condition: service_healthy

  nginx_$site_name:
    image: nginx:alpine
    container_name: nginx_$site_name
    restart: unless-stopped
    ports:
      - "$port:80"  # Semantic direct port mapping (8100+ range)
    depends_on:
      - wp_$site_name
    volumes:
      - ./wp_$site_name:/var/www/html:ro
      - $nginx_conf_path:/etc/nginx/conf.d/default.conf:ro
    networks:
      - wp-net

EOF

    # Copy the volumes section
    awk '/^volumes:/ {print; while(getline) print}' "$COMPOSE_FILE" >> "$temp_file"

    # Replace the original file
    mv "$temp_file" "$COMPOSE_FILE"

    # Create database and grant permissions
    if $DOCKER_COMPOSE ps db 2>/dev/null | grep -q "Up"; then
        $DOCKER_COMPOSE exec db mysql -u root -p"${MYSQL_ROOT_PASSWORD:-root}" \
            -e "CREATE DATABASE IF NOT EXISTS ${site_name}_db; GRANT ALL PRIVILEGES ON ${site_name}_db.* TO '${MYSQL_USER:-wp_user}'@'%'; FLUSH PRIVILEGES;" 2>/dev/null || true
    fi

    log_success "Site '$site_name' created successfully"
    echo "Direct: http://localhost:$port"  # Direct access via semantic port
    echo "Database: http://localhost:8200"  # phpMyAdmin access

    # Offer to start the site
    read -p "Start the site now? [Y/n]: " confirm
    if [[ ! "$confirm" =~ ^[Nn]$ ]]; then
        $DOCKER_COMPOSE up -d wp_$site_name nginx_$site_name 2>/dev/null || true
        log_success "Site '$site_name' started"
    fi
}

# List all sites
list_sites() {
    log_info "WordPress Sites:"
    echo ""
    
    local sites=($(get_sites))
    if [[ ${#sites[@]} -eq 0 ]]; then
        log_warning "No sites found"
        return
    fi
    
    printf "%-15s %-10s %-30s %-30s\n" "Site" "Status" "Local URL" "Domain URL"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    
    for site in "${sites[@]}"; do
        local status="Stopped"

        # Get the port for the site by examining the compose file
        local port="????"
        if [[ -f "$COMPOSE_FILE" ]]; then
            # Extract port from nginx service definition
            port=$(grep -A 10 "nginx_$site:" "$COMPOSE_FILE" | grep -oE '\- "[0-9]+:80"' | grep -oE '[0-9]+' | head -1)
            if [[ -z "$port" || "$port" == "" ]]; then
                port="????"
            fi
        fi

        if $DOCKER_COMPOSE ps --format "{{.Names}}" | grep -q "wp_$site"; then
            status="Running"
        fi

        printf "%-15s %-10s %-30s %-30s\n" "$site" "$status" \
            "http://localhost:$port" \
            "phpMyAdmin: http://localhost:8200"
    done
    echo ""
}

# Start environment
start_env() {
    log_info "Starting WordPress environment..."
    $DOCKER_COMPOSE up -d db redis phpmyadmin 2>/dev/null || true
    sleep 3

    # Start all WordPress sites
    for site in $(get_sites); do
        log_info "Starting $site..."
        $DOCKER_COMPOSE up -d "wp_$site" "nginx_$site" 2>/dev/null || true
    done

    log_success "Environment started"
    echo ""
    echo "Access URLs:"
    list_sites | grep -E "(Running|http|https)"
}

# Stop environment
stop_env() {
    log_info "Stopping WordPress environment..."
    $DOCKER_COMPOSE down
    log_success "Environment stopped"
}

# Show status
show_status() {
    log_info "System Status:"
    echo ""
    $DOCKER_COMPOSE ps
    echo ""
    list_sites
}

# Show logs
show_logs() {
    local service="$1"
    
    if [[ -n "$service" ]]; then
        if [[ "$service" == "db" ]]; then
            $DOCKER_COMPOSE logs -f db
        elif [[ "$service" == "nginx" ]]; then
            $DOCKER_COMPOSE logs -f traefik
        else
            $DOCKER_COMPOSE logs -f "wp_$service" "nginx_$service" 2>/dev/null || \
            $DOCKER_COMPOSE logs -f "$service"
        fi
    else
        $DOCKER_COMPOSE logs -f
    fi
}

# Remove site
remove_site() {
    local site_name="$1"

    if ! site_exists "$site_name"; then
        log_error "Site '$site_name' not found"
        return 1
    fi

    echo -e "${RED}WARNING: This will permanently delete '$site_name'${NC}"
    read -p "Continue? [y/N]: " confirm

    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        log_info "Cancelled"
        return
    fi

    log_info "Removing site '$site_name'..."

    # Stop services
    $DOCKER_COMPOSE stop "wp_$site_name" "nginx_$site_name" 2>/dev/null || true
    $DOCKER_COMPOSE rm -f "wp_$site_name" "nginx_$site_name" 2>/dev/null || true

    # Remove files
    rm -rf "$PROJECT_ROOT/wp_$site_name"
    rm -rf "$PROJECT_ROOT/logs/wp_$site_name"

    # Remove database
    if $DOCKER_COMPOSE ps db 2>/dev/null | grep -q "Up"; then
        $DOCKER_COMPOSE exec db mysql -u root -p"${MYSQL_ROOT_PASSWORD:-root}" \
            -e "DROP DATABASE IF EXISTS ${site_name}_db; REVOKE ALL PRIVILEGES ON ${site_name}_db.* FROM '${MYSQL_USER:-wp_user}'@'%'; FLUSH PRIVILEGES;" 2>/dev/null || true
    fi

    # Remove service definitions from docker-compose.yml
    if [[ -f "$COMPOSE_FILE" ]]; then
        local temp_file=$(mktemp)

        # Use sed to remove the complete service blocks for both wp_$site_name and nginx_$site_name
        # First remove entries with the comment marker
        sed "/# WordPress site: $site_name/,/^[^[:space:]#]/ {
            /# WordPress site: $site_name/!{
                /^[^[:space:]#]/!d;
            };
            /# WordPress site: $site_name/d;
        }" "$COMPOSE_FILE" > "$temp_file" 2>/dev/null || cp "$COMPOSE_FILE" "$temp_file"

        mv "$temp_file" "$COMPOSE_FILE"
    fi

    # Remove from .env file
    if [[ -f "$PROJECT_ROOT/.env" ]]; then
        local env_var_name=$(echo "$site_name" | tr '[:lower:]' '[:upper:]' | tr '-' '_')
        local temp_env=$(mktemp)
        grep -v "^${env_var_name}_PORT=" "$PROJECT_ROOT/.env" > "$temp_env"
        # Also remove the comment line that identifies the site
        grep -v "^# Site: $site_name" "$temp_env" > "$PROJECT_ROOT/.env"
        rm -f "$temp_env"
    fi

    log_success "Site '$site_name' removed"
}

# Code quality checks
run_checks() {
    log_info "Running code quality checks..."
    
    # Check if code quality containers exist in $DOCKER_COMPOSE
    if ! grep -q "phpcs" "$COMPOSE_FILE" 2>/dev/null; then
        log_warning "Code quality tools not configured"
        return
    fi
    
    # Start code quality tools if not running
    $DOCKER_COMPOSE --profile tools up -d phpcs phpstan 2>/dev/null || true
    
    # Run PHP CodeSniffer
    log_info "Running PHP CodeSniffer..."
    $DOCKER_COMPOSE run --rm phpcs phpcs --standard=WordPress \
        ./wp_*/wp-content/themes/ ./wp_*/wp-content/plugins/ 2>/dev/null || \
    log_warning "PHP CodeSniffer check completed with issues"
    
    # Run PHPStan
    log_info "Running PHPStan..."
    $DOCKER_COMPOSE run --rm phpstan phpstan analyse \
        ./wp_*/wp-content/themes/ ./wp_*/wp-content/plugins/ --level=5 2>/dev/null || \
    log_warning "PHPStan check completed with issues"
    
    log_info "Code quality checks completed"
}

# Access shell
access_shell() {
    local service="$1"
    
    case "$service" in
        "wp"|"wordpress")
            # Get running WordPress containers (exclude db)
            local running_containers=($($DOCKER_COMPOSE ps --format "{{.Names}}" 2>/dev/null | grep "^wp_" | grep -v "wp_db" || true))
            if [[ ${#running_containers[@]} -eq 0 ]]; then
                log_error "No WordPress containers running"
                return 1
            fi
            
            # Use first running WordPress container
            local container_name="${running_containers[0]}"
            echo "Accessing container: $container_name"
            $DOCKER_COMPOSE exec "$container_name" bash || \
            log_error "Failed to access WordPress container"
            ;;
        "db"|"database")
            $DOCKER_COMPOSE exec db mysql -u root -p"${MYSQL_ROOT_PASSWORD:-root}"
            ;;
        "nginx"|"proxy")
            $DOCKER_COMPOSE exec traefik sh 2>/dev/null || \
            log_error "Traefik container not running"
            ;;
        *)
            log_error "Unknown service: $service"
            echo "Available: wp, db, nginx"
            return 1
            ;;
    esac
}

# Show URLs
show_urls() {
    local site_name="$1"

    if [[ -n "$site_name" ]]; then
        if site_exists "$site_name"; then
            # Get the port for the site by examining the compose file
            local port="????"
            if [[ -f "$COMPOSE_FILE" ]]; then
                port=$(grep -A 10 "nginx_$site_name:" "$COMPOSE_FILE" | grep -oE '\- "[0-9]+:80"' | grep -oE '[0-9]+' | head -1)
                if [[ -z "$port" || "$port" == "" ]]; then
                    port="????"
                fi
            fi
            echo "Access: http://localhost:$port"
            echo "Database: http://localhost:8200"
        else
            log_error "Site '$site_name' not found"
        fi
    else
        echo "Services:"
        echo "WordPress sites: http://localhost:[assigned_port]"
        echo "Database admin: http://localhost:8200"
        echo "Email viewer: https://mailhog.$DOMAIN_SUFFIX"
    fi
}

# Setup environment
setup_env() {
    log_info "Setting up simplified WordPress environment..."
    
    # Create .env if not exists
    if [[ ! -f "$PROJECT_ROOT/.env" ]]; then
        cat > "$PROJECT_ROOT/.env" << EOF
# Simplified WordPress Environment
DOMAIN_SUFFIX=127.0.0.1.nip.io
MYSQL_USER=wp_user
MYSQL_PASSWORD=wp_password
MYSQL_ROOT_PASSWORD=root_password
WP_DEBUG=true
EOF
        log_success "Created .env file"
    fi
    
    # Create simplified $DOCKER_COMPOSE.yml if not exists
    if [[ ! -f "$PROJECT_ROOT/$DOCKER_COMPOSE.yml" ]]; then
        cat > "$PROJECT_ROOT/$DOCKER_COMPOSE.yml" << EOF
version: '3.8'

networks:
  wp-net:
    driver: bridge

services:
  # Database
  db:
    image: mysql:8.0
    container_name: wp_db
    restart: unless-stopped
    ports:
      - "3306:3306"
    environment:
      MYSQL_ROOT_PASSWORD: \${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: wp_main
      MYSQL_USER: \${MYSQL_USER}
      MYSQL_PASSWORD: \${MYSQL_PASSWORD}
    volumes:
      - wp_db_data:/var/lib/mysql
    networks:
      - wp-net

  # Cache
  redis:
    image: redis:alpine
    container_name: wp_redis
    restart: unless-stopped
    networks:
      - wp-net

  # Reverse proxy
  traefik:
    image: traefik:v2.10
    container_name: wp_traefik
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
      - "8080:8080"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    command:
      - "--api.dashboard=true"
      - "--providers.docker=true"
      - "--entrypoints.web.address=:80"
      - "--entrypoints.websecure.address=:443"
      - "--entrypoints.web.http.redirections.entryPoint.to=websecure"
      - "--entrypoints.web.http.redirections.entryPoint.scheme=https"
      - "--serverstransport.insecureskipverify=true"
    networks:
      - wp-net

volumes:
  wp_db_data:
EOF
        log_success "Created $DOCKER_COMPOSE.yml"
    fi
    
    # Create config directories
    mkdir -p "$PROJECT_ROOT/config/nginx"
    
    # Create default nginx config
    if [[ ! -f "$PROJECT_ROOT/config/nginx/default.conf" ]]; then
        cat > "$PROJECT_ROOT/config/nginx/default.conf" << 'EOF'
server {
    listen 80 default_server;
    server_name _;
    root /var/www/html;
    index index.php index.html;

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location ~ \.php$ {
        fastcgi_pass localhost:9000;  # Default to localhost for single container use
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    }
}
EOF
        log_success "Created default nginx configuration"
    fi
    
    # Ensure the wp_ directory exists for the main project (if this is the root)
    if [[ ! -d "$PROJECT_ROOT/wp_" ]]; then
        mkdir -p "$PROJECT_ROOT/wp_"
        # This is for the main project directory if needed
    fi

    log_success "Setup complete! Run './wp-simple start' to begin"
}

# Install complete WordPress environment with one command
install_env() {
    local site_name="${1:-wordpress}"

    log_info "Installing complete WordPress environment..."

    # Make sure we have the simple compose file
    if [[ ! -f "$PROJECT_ROOT/docker-compose.simple.yml" ]]; then
        log_error "docker-compose.simple.yml not found"
        return 1
    fi

    # Always create or overwrite the compose file with Traefik-free version
    cat > "$PROJECT_ROOT/docker-compose.yml" << 'EOF'
version: '3.8'

networks:
  wp-net:
    driver: bridge

services:
  # Database
  db:
    image: mysql:8.0
    container_name: wp_db
    restart: unless-stopped
    ports:
      - "3306:3306"
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: wp_main
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
    volumes:
      - wp_db_data:/var/lib/mysql
    networks:
      - wp-net
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      timeout: 20s
      retries: 10

  # Cache
  redis:
    image: redis:alpine
    container_name: wp_redis
    restart: unless-stopped
    networks:
      - wp-net
    command: redis-server --maxmemory 256mb --maxmemory-policy allkeys-lru

  # Database admin panel
  phpmyadmin:
    image: phpmyadmin:latest
    container_name: wp_phpmyadmin
    restart: unless-stopped
    ports:
      - "8200:80"  # Direct access to phpMyAdmin
    environment:
      PMA_HOST: db
      PMA_USER: ${MYSQL_USER:-wp_user}
      PMA_PASSWORD: ${MYSQL_PASSWORD:-wp_password}
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD:-root}
    networks:
      - wp-net
    depends_on:
      - db

volumes:
  wp_db_data:
EOF
    log_success "Created Traefik-free docker-compose.yml"

    # Run setup if .env doesn't exist
    if [[ ! -f "$PROJECT_ROOT/.env" ]]; then
        setup_env
    fi

    # Start the base services (db, redis, traefik)
    log_info "Starting base services..."
    if ! $DOCKER_COMPOSE up -d db redis traefik; then
        # If traefik fails due to port conflicts, try to stop conflicting containers first
        log_warning "Traefik failed to start, checking for conflicting containers..."
        docker ps --format "table {{.Names}}\t{{.Ports}}" | grep -E "(traefik|80->|443->|8080->)" || true

        # Try to stop any existing traefik containers
        docker stop $(docker ps -q --filter "name=traefik") 2>/dev/null || true
        docker stop $(docker ps -q --filter "name=wp_traefik") 2>/dev/null || true

        # Retry starting services
        log_info "Retrying to start services..."
        $DOCKER_COMPOSE up -d db redis traefik || {
            log_warning "Could not start Traefik (port may be in use), starting other services..."
            $DOCKER_COMPOSE up -d db redis
        }
    fi

    # Wait for database to be ready
    log_info "Waiting for database to be ready..."
    local max_attempts=30
    local attempt=1
    while [[ $attempt -le $max_attempts ]]; do
        if $DOCKER_COMPOSE exec db mysqladmin ping -h localhost -u "${MYSQL_USER:-wp_user}" -p"${MYSQL_PASSWORD:-wp_password}" --silent; then
            log_success "Database is ready!"
            break
        else
            log_info "Waiting for database... ($attempt/$max_attempts)"
            sleep 5
            ((attempt++))
        fi
    done

    if [[ $attempt -gt $max_attempts ]]; then
        log_error "Database failed to start after $max_attempts attempts"
        return 1
    fi

    # Check if site already exists
    if ! site_exists "$site_name"; then
        log_info "Creating WordPress site: $site_name"
        create_site "$site_name"
    else
        log_info "Site '$site_name' already exists"
    fi

    # Start all services
    log_info "Starting all services..."
    start_env

    log_success "WordPress environment installed successfully!"
    echo ""
    echo "Your site is available at:"
    echo "  http://$site_name.$DOMAIN_SUFFIX"
    echo "  https://$site_name.$DOMAIN_SUFFIX"
    echo ""
    log_info "Note: If Traefik dashboard is needed, it should be available at http://localhost:8080"
    log_success "Installation complete! ðŸš€"
}

# Database import function
import_db() {
    local site_name="$1"
    local dump_file="$2"

    if [[ -z "$site_name" || -z "$dump_file" ]]; then
        log_error "Usage: ./wp-simple import-db <site-name> </path/to/dump.sql>"
        return 1
    fi

    if [[ ! -f "$dump_file" ]]; then
        log_error "Dump file not found: $dump_file"
        return 1
    fi

    if ! site_exists "$site_name"; then
        log_error "Site '$site_name' not found"
        return 1
    fi

    local db_name="${site_name}_db"
    log_info "Importing database for '$site_name' ($db_name)..."

    # Import the SQL dump
    cat "$dump_file" | docker-compose exec -T db mysql -u "${MYSQL_USER:-wp_user}" -p"${MYSQL_PASSWORD:-wp_password}" "$db_name"

    if [[ $? -eq 0 ]]; then
        log_success "Database imported successfully for '$site_name'"
    else
        log_error "Failed to import database for '$site_name'"
        return 1
    fi
}

# Database export function
export_db() {
    local site_name="$1"
    local output_file="$2"

    if [[ -z "$site_name" ]]; then
        log_error "Usage: ./wp-simple export-db <site-name> [/path/to/output.sql]"
        return 1
    fi

    if ! site_exists "$site_name"; then
        log_error "Site '$site_name' not found"
        return 1
    fi

    local db_name="${site_name}_db"

    if [[ -z "$output_file" ]]; then
        output_file="${site_name}_$(date +%Y%m%d_%H%M%S).sql"
        log_info "Exporting database for '$site_name' to $output_file..."
    else
        log_info "Exporting database for '$site_name' to $output_file..."
    fi

    # Export the database
    docker-compose exec db mysqldump -u "${MYSQL_USER:-wp_user}" -p"${MYSQL_PASSWORD:-wp_password}" "$db_name" > "$output_file"

    if [[ $? -eq 0 ]]; then
        log_success "Database exported successfully to '$output_file'"
        echo "File size: $(du -h "$output_file" | cut -f1)"
    else
        log_error "Failed to export database for '$site_name'"
        return 1
    fi
}

# Clean up
clean_env() {
    log_warning "This will remove unused Docker resources"
    read -p "Continue? [y/N]: " confirm

    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        docker system prune -f
        docker volume prune -f
        log_success "Cleanup complete"
    fi
}

# Main command dispatcher
main() {
    if [[ $# -eq 0 ]]; then
        show_help
        return
    fi
    
    local command="$1"
    shift
    
    case "$command" in
        "setup")
            setup_env "$@"
            ;;
        "start")
            start_env "$@"
            ;;
        "stop")
            stop_env "$@"
            ;;
        "restart")
            stop_env
            start_env
            ;;
        "status")
            show_status "$@"
            ;;
        "logs")
            show_logs "$@"
            ;;
        "create")
            create_site "$@"
            ;;
        "list"|"ls")
            list_sites "$@"
            ;;
        "remove"|"rm")
            remove_site "$@"
            ;;
        "info")
            show_urls "$@"
            ;;
        "check"|"quality")
            run_checks "$@"
            ;;
        "test")
            run_checks "$@"  # Same as check for now
            ;;
        "fix")
            log_info "Auto-fix not implemented yet"
            ;;
        "shell")
            access_shell "$@"
            ;;
        "url"|"urls")
            show_urls "$@"
            ;;
        "clean")
            clean_env "$@"
            ;;
        "install")
            install_env "$@"
            ;;
        "import-db")
            import_db "$@"
            ;;
        "export-db")
            export_db "$@"
            ;;
        "help"|"-h"|"--help")
            show_help
            ;;
        *)
            log_error "Unknown command: $command"
            show_help
            return 1
            ;;
    esac
}

main "$@"